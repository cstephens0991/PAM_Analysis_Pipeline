## get_fvfm_v3.0

# This script is used to carry out the first stage of the PAM data analysis pipeline

# If using this script **it is important to acknowledge the code contributors**:
# - pim2tiff.exe was developed and provided by Oliver Meyerhoff of Walz (supplier of the PAM imager)
# - The Multi2singleframes.extract_frame script is an edited version of that developed by Dominik Schneider et al. and published here (https://doi.org/10.1186/s13007-019-0546-1). See also GitHub for source scripts (https://github.com/CougPhenomics/ImagingPAMProcessing).
# - The plantcv_current.yml environment file was also sourced from scripts written by Schneider et al.
# - The FvFm calculations were carried out using scripts generated by PlantCV. See https://plantcv.readthedocs.io/en/stable/photosynthesis_analyze_fvfm/ for tutorial and GitHub (https://github.com/danforthcenter/plantcv/blob/main/plantcv/plantcv/photosynthesis/analyze_fvfm.py) for source scripts.

# Before running locally, it is necessary to generate a conda environment, using the get_fvfm_environment.yml file.

### Import all required scripts and functions:
import re
import os
import glob
import shutil
import pandas as pd
import numpy as np
import math
import argparse
import time

# Required for setting threshold images (and subsequent cleaning)
from plantcv import plantcv as pcv
from skimage import filters

# Edited FvFm value extraction script
from scripts import Analyse_FvFm_new

# Convert tiff stack to individual files
from scripts import Multi2Singleframes
# Run executable
import subprocess
# Cut up tiff images
from PIL import Image

# Required for image export in ProcessImages.py script (not yet used here...)
import cv2 as cv2

def main():
    ## set global variables
    global debug_cropped
    global xpim_dir
    global tif_dir
    global outpath
    global wells
    ##### Parse arguments and check directories, make new if needed
    xpim_dir, tif_dir, outpath, well_coord, coord_format, thresh = parsing_arguments()
    check_dirs()

    ##### Get list of files to analyse
    xpim_files = glob.glob(f"{xpim_dir}/*.xpim")
    xpim_bn = [os.path.splitext(os.path.basename(filepath))[0] for filepath in xpim_files]

    ##### Convert xpim files to tif files. This utilises the "pim2tif.exe" executable.
    # this executes pim2tiff.exe (only for windows), and creates several tif files (tif stack)
    #subprocess.check_call(["./scripts/pim2tiff.exe", f"{xpim_dir}"])

    ##### Move tif files to the input/tif_files folder
    [shutil.move(f"{xpim_dir}/{bn}.xpim", f"{tif_dir}/{bn}.tif") for bn in xpim_bn]

    ##### Separate the tif stacks in to individual images
    for tif_stack in glob.glob("./input/tif_files/*.tif"):
        Multi2Singleframes.extract_frames(tif_stack, f"{tif_dir}/tif_frames")

    ##### Read well_coord file, and convert to dictionary (Well_1: [coord1,coord2,coord3,coord4])
    # Note: Please check at the end of the data extraction process, that all the leaf area (and none from neighbouring wells) has been successfully captured.
    wells = pd.read_csv(well_coord, sep = ",").to_dict(orient = "list")
    ## Check the format of the well coordinates
    if (coord_format == 'auto' and is_imageJ_coord(wells) == True) or (coord_format == 'imagej'):
        print("Converting input coordinates to PlantCV-formatted coordinates.")
        wells = convert2plantcv(wells)
    elif (coord_format == 'auto' and is_imageJ_coord(wells) == False) or (coord_format == 'plantcv'):
        print("Treating input coordinates as PlantCV-formatted coordinates.")

    ##### Analyse images and compute fvfm
    # Create output pandas df
    output_df = pd.DataFrame([], columns = ["Plate", "Well", "FvFm"])
    # For each file to analyse, generate and export the "fmax" image. This can be used for later debugging
    # Count for the number of plate image files analysed
    file_count = 0
    ## For each basename (plate_name), generate and write a threshold image
    for image_file in xpim_bn:
        print(f"Analysing {image_file}")
        file_count = file_count + 1
        fmax_plate, threshold_image = generate_threshold_image(tif_dir, image_file, thresh, outpath)

        ## For each well in the well_coordinate file, compute fvfm
        print("Analysing each specified Well in the plate, based on the well coordinate file...")
        for key in wells.keys():
            df, well_thresh_image = get_fvfm_per_well(image_file, key, thresh, fmax_plate)
            output_df = pd.concat([output_df, df])
            # Export threshold images to debug folder
            cv2.imwrite(f"{debug_cropped}/threshold/{image_file}_threshold_{key}.tif", well_thresh_image)
    output_df = output_df.reset_index().drop(columns="index")
    output_df.to_csv(f"{outpath}/FvFm_output.csv")

    print(f"End of script. Number of files analysed: {file_count}")

    # Finally, remove unnecessary directories
    shutil.rmtree(f"{debug_cropped}/fmin", ignore_errors=True)
    shutil.rmtree(f"{debug_cropped}/fdark", ignore_errors=True)
    shutil.rmtree(f"{tif_dir}/tif_frames/", ignore_errors=True)
    # fmax and threshold will be kept for debugging purposes.

def parsing_arguments():
    timestamp = time.strftime('%Y%m%d-%H%M%S')
    parser = argparse.ArgumentParser(
        prog='get_fvfm_v3.py',
        description='This script is used to carry out the first stage of the PAM data analysis pipeline.')
    parser.add_argument('--xpim-dir',
                        help="Path to directory containing the *.xpim files.", default = "./input/xpim_files/")
    parser.add_argument('--tif-dir',
                        help="Path to directory containing the *.tif files.", default = "./input/tif_files/")
    parser.add_argument('--outpath',
                        help="Path to output directory which will contain results of current run.", default=f"./output_{timestamp}/")
    parser.add_argument('--well-coord', 
                        help = """
                        CSV file containing the well coordinates. The columns should be the Well names (well_1, well_2 etc), and the rows contain the coordinates (x1,y1,x2,y2). If format is imagej, specify in coord_format option.", 
                        default = "./input/24_wells_transposed.csv
                        """)
    parser.add_argument('--coord-format', default = "auto", help = """
                        Format of well coordinates. ImageJ sees Well coordinates as:  [100, 130, 70, 70]  , corresponding to [x_start, y_start, x_width, y_width].
                        PlantCV sees Well coordinates as: [100, 130, 170, 200], corresponding to [x_start, y_start, x_end, y_end]. 
                        By default, it will try to detect the format ('auto'), but can be set to 'plantcv' or 'imagej' (case-sensitive).
                        """)
    parser.add_argument('--threshold', default = "yen", 
                        help = "Threshold to define plant material from background. Default is Yen's threshold, as defined by Mister Yen.")
    args = vars(parser.parse_args())
    xpim_dir = os.path.abspath(args["xpim_dir"])
    tif_dir = os.path.abspath(args["tif_dir"])
    outpath = os.path.abspath(args["outpath"])
    well_coord = os.path.abspath(args["well_coord"])
    coord_format = args["coord_format"]
    threshold = args["threshold"]
    return xpim_dir, tif_dir, outpath, well_coord, coord_format, threshold

def check_dirs():
    ######## Take care of directories #########
    if not os.path.exists(tif_dir):
        os.makedirs(tif_dir)
    # Delete any tiff_frames file that already exists and replace with an empty one
    if os.path.exists(f"{tif_dir}/tif_frames/"):
        shutil.rmtree(f"{tif_dir}/tif_frames/")
    os.makedirs(f"{tif_dir}/tif_frames/")
    # Delete any previously existing debug folder and replace with empty directories
    debug_cropped = "./debug/cropped_images"
    if os.path.exists(debug_cropped):
        shutil.rmtree(debug_cropped)
    subdirs = ["fmin", "fmax", "fdark", "threshold"]
    [os.makedirs(f"{debug_cropped}/{subdir}") for subdir in subdirs]
    ## output directory
    if not os.path.exists(f"{outpath}/threshold_output/"):
        os.makedirs(f"{outpath}/threshold_output/")
    ###########################################

def is_imageJ_coord(csv_dict):
    """
    is_imageJ_coord will try to automatically detect the format of the input well coordinates. To do this, it assumes that all wells have equal widths. 
    Therefore, it simply checks whether the last 2 elements of each Well_coord array are always the same. If so, returns True, else returns False.
    """
    csv_df = pd.DataFrame.from_dict(csv_dict, orient = 'columns')
    x_end = np.unique(csv_df.loc[2])
    y_end = np.unique(csv_df.loc[3])
    print(f"x_end has {len(x_end)} values, and y_end has {len(y_end)} values.")
    if (len(x_end) == 1) and (len(y_end) == 1):
        print("Detected ImageJ format for well coordinates.")
        return True
    else:
        print("Detected coordinate format different from ImageJ.")
        return False

def convert2plantcv(csv_dict):
    """
    Convert2plantcv is a function that will transform the Plate Well coordinates from the ImageJ format, to the one that PlantCV uses. 
    ImageJ sees Well coordinates as:  [100, 130, 70, 70]  , corresponding to [x_start, y_start, x_width, y_width].
    PlantCV sees Well coordinates as: [100, 130, 170, 200], corresponding to [x_start, y_start, x_end, y_end]. 
    This script will be able to take in both types of coordinates, but if the format is ImageJ, it will convert the data to a PlantCV compatible format. 
    """
    plantcv_coord = {}
    for key, value in csv_dict.items():
        x_start = value[0]; y_start = value[1]; x_width = value[2]; y_width = value[3]
        plantcv_coord[key] = [x_start, y_start, x_start+x_width, y_start+y_width]
        # print(f"{key}: {csv_dict[key]}")
        # print(f"{key}: {new_dict[key]}")
    return plantcv_coord

def generate_threshold_image(tif_dir, image_file, thresh):
    # Create contrast image and save to output/threshold_output folder
    #fmin_plate, path, filename = pcv.readimage(f"{tif_dir}/tif_frames/{image_file}-1.tif", mode = "native")
    fmax_plate, _, _ = pcv.readimage(f"{tif_dir}/tif_frames/{image_file}-2.tif", mode = "native")
    #fdark_plate, path, filename = pcv.readimage(f"{tif_dir}/tif_frames/{image_file}-3.tif", mode = "native")
    if thresh == "yen":
        threshold_lvl = filters.threshold_yen(image=fmax_plate)
    else:
        threshold_lvl = thresh
    threshold_image = pcv.threshold.binary(gray_img = fmax_plate, threshold = threshold_lvl, object_type = 'light')
    threshold_image = pcv.fill(threshold_image, size = 5)
    cv2.imwrite(f"{outpath}/threshold_output/{image_file}_threshold_image.tif", threshold_image)
    return fmax_plate, threshold_image

def get_fvfm_per_well(image_file, key, thresh, fmax_plate):
    # Create images for each well
    # For each plate image, the image is opened, cropped and the cropped image is saved
    with Image.open(f"{tif_dir}/tif_frames/{image_file}-1.tif") as plate_fmin:
        cropped_fmin = plate_fmin.crop(wells[key])
        cropped_fmin.save(f"{debug_cropped}/fmin/{image_file}_fmin_{key}.tif", format=None)
        
    with Image.open(f"{tif_dir}/tif_frames/{image_file}-2.tif") as plate_fmax:
        cropped_fmax = plate_fmax.crop(wells[key])
        cropped_fmax.save(f"{debug_cropped}/fmax/{image_file}_fmax_{key}.tif", format=None)
        
    with Image.open(f"{tif_dir}/tif_frames/{image_file}-3.tif") as plate_fdark:
        cropped_fdark = plate_fdark.crop(wells[key])
        cropped_fdark.save(f"{debug_cropped}/fdark/{image_file}_fdark_{key}.tif", format=None)
    
    # Read back in using pcv functions (reads in images as numpy arrays)
    fmin, _, _ = pcv.readimage(f"{debug_cropped}/fmin/{image_file}_fmin_{key}.tif", mode="native")
    fmax, _, _ = pcv.readimage(f"{debug_cropped}/fmax/{image_file}_fmax_{key}.tif", mode="native")
    fdark, _, _ = pcv.readimage(f"{debug_cropped}/fdark/{image_file}_fdark_{key}.tif", mode="native")

    # Return threshold value based on Yen’s method.
    if thresh == "yen":
        threshold_lvl = filters.threshold_yen(image=fmax_plate)
    else:
        threshold_lvl = thresh
    # Use the threshold value to filter out highlighted plate areas
    threshold_image = pcv.threshold.binary(gray_img=fmax, threshold=threshold_lvl, object_type='light')
    threshold_image = pcv.fill(threshold_image, size=5)

    # Carry out FvFm calculation
    part_Fv = Analyse_FvFm_new.analyze_fvfm(fdark=fdark, fmin=fmin, fmax=fmax, mask=threshold_image, bins=256, label="fluor")
    if math.isnan(part_Fv):
        print(f"fvfm for {image_file}, {key} is nan!")
    df = pd.DataFrame([[image_file, key, part_Fv]], columns = ["Plate", "Well", "FvFm"])
    return df, threshold_image

if __name__ == '__main__':
    main()